// node_modules/d3-collection/src/map.js
var prefix = "$";
function Map() {
}
Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return prefix + key in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this)
      if (property[0] === prefix)
        delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this)
      if (property[0] === prefix)
        keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this)
      if (property[0] === prefix)
        values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this)
      if (property[0] === prefix)
        entries.push({ key: property.slice(1), value: this[property] });
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this)
      if (property[0] === prefix)
        ++size;
    return size;
  },
  empty: function() {
    for (var property in this)
      if (property[0] === prefix)
        return false;
    return true;
  },
  each: function(f) {
    for (var property in this)
      if (property[0] === prefix)
        f(this[property], property.slice(1), this);
  }
};
function map(object, f) {
  var map2 = new Map();
  if (object instanceof Map)
    object.each(function(value, key2) {
      map2.set(key2, value);
    });
  else if (Array.isArray(object)) {
    var i = -1, n = object.length, o;
    if (f == null)
      while (++i < n)
        map2.set(i, object[i]);
    else
      while (++i < n)
        map2.set(f(o = object[i], i, object), o);
  } else if (object)
    for (var key in object)
      map2.set(key, object[key]);
  return map2;
}
var map_default = map;

// node_modules/d3-collection/src/nest.js
function nest_default() {
  var keys = [], sortKeys = [], sortValues, rollup, nest;
  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null)
        array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }
    var i = -1, n = array.length, key = keys[depth++], keyValue, value, valuesByKey = map_default(), values, result = createResult();
    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }
    valuesByKey.each(function(values2, key2) {
      setResult(result, key2, apply(values2, depth, createResult, setResult));
    });
    return result;
  }
  function entries(map2, depth) {
    if (++depth > keys.length)
      return map2;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length)
      array = map2.entries();
    else
      array = [], map2.each(function(v, k) {
        array.push({ key: k, values: entries(v, depth) });
      });
    return sortKey != null ? array.sort(function(a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }
  return nest = {
    object: function(array) {
      return apply(array, 0, createObject, setObject);
    },
    map: function(array) {
      return apply(array, 0, createMap, setMap);
    },
    entries: function(array) {
      return entries(apply(array, 0, createMap, setMap), 0);
    },
    key: function(d) {
      keys.push(d);
      return nest;
    },
    sortKeys: function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    },
    sortValues: function(order) {
      sortValues = order;
      return nest;
    },
    rollup: function(f) {
      rollup = f;
      return nest;
    }
  };
}
function createObject() {
  return {};
}
function setObject(object, key, value) {
  object[key] = value;
}
function createMap() {
  return map_default();
}
function setMap(map2, key, value) {
  map2.set(key, value);
}

// node_modules/d3-collection/src/set.js
function Set() {
}
var proto = map_default.prototype;
Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};
function set(object, f) {
  var set2 = new Set();
  if (object instanceof Set)
    object.each(function(value) {
      set2.add(value);
    });
  else if (object) {
    var i = -1, n = object.length;
    if (f == null)
      while (++i < n)
        set2.add(object[i]);
    else
      while (++i < n)
        set2.add(f(object[i], i, object));
  }
  return set2;
}
var set_default = set;

// node_modules/d3-collection/src/keys.js
function keys_default(map2) {
  var keys = [];
  for (var key in map2)
    keys.push(key);
  return keys;
}

// node_modules/d3-collection/src/values.js
function values_default(map2) {
  var values = [];
  for (var key in map2)
    values.push(map2[key]);
  return values;
}

// node_modules/d3-collection/src/entries.js
function entries_default(map2) {
  var entries = [];
  for (var key in map2)
    entries.push({ key, value: map2[key] });
  return entries;
}
export {
  entries_default as entries,
  keys_default as keys,
  map_default as map,
  nest_default as nest,
  set_default as set,
  values_default as values
};
//# sourceMappingURL=d3-collection.js.map
