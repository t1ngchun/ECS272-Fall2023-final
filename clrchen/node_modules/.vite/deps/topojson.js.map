{
  "version": 3,
  "sources": ["../../topojson-client/src/identity.js", "../../topojson-client/src/transform.js", "../../topojson-client/src/bbox.js", "../../topojson-client/src/reverse.js", "../../topojson-client/src/feature.js", "../../topojson-client/src/stitch.js", "../../topojson-client/src/mesh.js", "../../topojson-client/src/merge.js", "../../topojson-client/src/bisect.js", "../../topojson-client/src/neighbors.js", "../../topojson-client/src/untransform.js", "../../topojson-client/src/quantize.js", "../../topojson-server/src/bounds.js", "../../topojson-server/src/hash/hashset.js", "../../topojson-server/src/hash/hashmap.js", "../../topojson-server/src/hash/point-equal.js", "../../topojson-server/src/hash/point-hash.js", "../../topojson-server/src/join.js", "../../topojson-server/src/cut.js", "../../topojson-server/src/dedup.js", "../../topojson-server/src/delta.js", "../../topojson-server/src/extract.js", "../../topojson-server/src/geometry.js", "../../topojson-server/src/prequantize.js", "../../topojson-server/src/topology.js", "../../topojson-simplify/src/prune.js", "../../topojson-simplify/src/filter.js", "../../topojson-simplify/src/filterAttached.js", "../../topojson-simplify/src/planar.js", "../../topojson-simplify/src/filterWeight.js", "../../topojson-simplify/src/filterAttachedWeight.js", "../../topojson-simplify/src/heap.js", "../../topojson-simplify/src/presimplify.js", "../../topojson-simplify/src/quantile.js", "../../topojson-simplify/src/simplify.js", "../../topojson-simplify/src/spherical.js"],
  "sourcesContent": ["export default function(x) {\n  return x;\n}\n", "import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n", "import transform from \"./transform\";\n\nexport default function(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n", "export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n", "import reverse from \"./reverse\";\nimport transform from \"./transform\";\n\nexport default function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nexport function feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n", "export default function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n", "import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nexport default function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nexport function meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n", "import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n", "export default function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n", "import bisect from \"./bisect\";\n\nexport default function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n", "import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n", "import bbox from \"./bbox\";\nimport untransform from \"./untransform\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n", "// Computes the bounding box of the specified hash of GeoJSON objects.\nexport default function(objects) {\n  var x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  function boundGeometry(geometry) {\n    if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n  }\n\n  var boundGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },\n    Point: function(o) { boundPoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },\n    LineString: function(o) { boundLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs.forEach(boundLine); },\n    Polygon: function(o) { o.arcs.forEach(boundLine); },\n    MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }\n  };\n\n  function boundPoint(coordinates) {\n    var x = coordinates[0],\n        y = coordinates[1];\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  function boundLine(coordinates) {\n    coordinates.forEach(boundPoint);\n  }\n\n  function boundMultiLine(coordinates) {\n    coordinates.forEach(boundLine);\n  }\n\n  for (var key in objects) {\n    boundGeometry(objects[key]);\n  }\n\n  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n}\n", "export default function(size, hash, equal, type, empty) {\n  if (arguments.length === 3) {\n    type = Array;\n    empty = null;\n  }\n\n  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    store[i] = empty;\n  }\n\n  function add(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) throw new Error(\"full hashset\");\n      match = store[index = (index + 1) & mask];\n    }\n    store[index] = value;\n    return true;\n  }\n\n  function has(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) break;\n      match = store[index = (index + 1) & mask];\n    }\n    return false;\n  }\n\n  function values() {\n    var values = [];\n    for (var i = 0, n = store.length; i < n; ++i) {\n      var match = store[i];\n      if (match != empty) values.push(match);\n    }\n    return values;\n  }\n\n  return {\n    add: add,\n    has: has,\n    values: values\n  };\n}\n", "export default function(size, hash, equal, keyType, keyEmpty, valueType) {\n  if (arguments.length === 3) {\n    keyType = valueType = Array;\n    keyEmpty = null;\n  }\n\n  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      valstore = new valueType(size),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    keystore[i] = keyEmpty;\n  }\n\n  function set(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index] = value;\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function maybeSet(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function get(key, missingValue) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) break;\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    return missingValue;\n  }\n\n  function keys() {\n    var keys = [];\n    for (var i = 0, n = keystore.length; i < n; ++i) {\n      var matchKey = keystore[i];\n      if (matchKey != keyEmpty) keys.push(matchKey);\n    }\n    return keys;\n  }\n\n  return {\n    set: set,\n    maybeSet: maybeSet, // set if unset\n    get: get,\n    keys: keys\n  };\n}\n", "export default function(pointA, pointB) {\n  return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n}\n", "// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16),\n    floats = new Float64Array(buffer),\n    uints = new Uint32Array(buffer);\n\nexport default function(point) {\n  floats[0] = point[0];\n  floats[1] = point[1];\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n}\n", "import hashset from \"./hash/hashset\";\nimport hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given an extracted (pre-)topology, identifies all of the junctions. These are\n// the points at which arcs (lines or rings) will need to be cut so that each\n// arc is represented uniquely.\n//\n// A junction is a point where at least one arc deviates from another arc going\n// through the same point. For example, consider the point B. If there is a arc\n// through ABC and another arc through CBA, then B is not a junction because in\n// both cases the adjacent point pairs are {A,C}. However, if there is an\n// additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.\n//\n// For a closed ring ABCA, the first point A’s adjacent points are the second\n// and last point {B,C}. For a line, the first and last point are always\n// considered junctions, even if the line is closed; this ensures that a closed\n// line is never rotated.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      indexes = index(),\n      visitedByIndex = new Int32Array(coordinates.length),\n      leftByIndex = new Int32Array(coordinates.length),\n      rightByIndex = new Int32Array(coordinates.length),\n      junctionByIndex = new Int8Array(coordinates.length),\n      junctionCount = 0, // upper bound on number of junctions\n      i, n,\n      previousIndex,\n      currentIndex,\n      nextIndex;\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n  }\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineStart = line[0],\n        lineEnd = line[1];\n    currentIndex = indexes[lineStart];\n    nextIndex = indexes[++lineStart];\n    ++junctionCount, junctionByIndex[currentIndex] = 1; // start\n    while (++lineStart <= lineEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n    }\n    ++junctionCount, junctionByIndex[nextIndex] = 1; // end\n  }\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = -1;\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0] + 1,\n        ringEnd = ring[1];\n    previousIndex = indexes[ringEnd - 1];\n    currentIndex = indexes[ringStart - 1];\n    nextIndex = indexes[ringStart];\n    sequence(i, previousIndex, currentIndex, nextIndex);\n    while (++ringStart <= ringEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n    }\n  }\n\n  function sequence(i, previousIndex, currentIndex, nextIndex) {\n    if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection\n    visitedByIndex[currentIndex] = i;\n    var leftIndex = leftByIndex[currentIndex];\n    if (leftIndex >= 0) {\n      var rightIndex = rightByIndex[currentIndex];\n      if ((leftIndex !== previousIndex || rightIndex !== nextIndex)\n        && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n        ++junctionCount, junctionByIndex[currentIndex] = 1;\n      }\n    } else {\n      leftByIndex[currentIndex] = previousIndex;\n      rightByIndex[currentIndex] = nextIndex;\n    }\n  }\n\n  function index() {\n    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n        indexes = new Int32Array(coordinates.length);\n\n    for (var i = 0, n = coordinates.length; i < n; ++i) {\n      indexes[i] = indexByPoint.maybeSet(i, i);\n    }\n\n    return indexes;\n  }\n\n  function hashIndex(i) {\n    return hashPoint(coordinates[i]);\n  }\n\n  function equalIndex(i, j) {\n    return equalPoint(coordinates[i], coordinates[j]);\n  }\n\n  visitedByIndex = leftByIndex = rightByIndex = null;\n\n  var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;\n\n  // Convert back to a standard hashset by point for caller convenience.\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    if (junctionByIndex[j = indexes[i]]) {\n      junctionByPoint.add(coordinates[j]);\n    }\n  }\n\n  return junctionByPoint;\n}\n", "import join from \"./join\";\n\n// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\nexport default function(topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i, n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = {0: lineMid, 1: line[1]};\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = {0: ringMid, 1: ring[1]};\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else { // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n}\n\nfunction rotateArray(array, start, end, offset) {\n  reverse(array, start, end);\n  reverse(array, start, start + offset);\n  reverse(array, start + offset, end);\n}\n\nfunction reverse(array, start, end) {\n  for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}\n", "import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given a cut topology, combines duplicate arcs.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n}\n", "// Given an array of arcs in absolute (but already quantized!) coordinates,\n// converts to fixed-point delta encoding.\n// This is a destructive operation that modifies the given arcs!\nexport default function(arcs) {\n  var i = -1,\n      n = arcs.length;\n\n  while (++i < n) {\n    var arc = arcs[i],\n        j = 0,\n        k = 1,\n        m = arc.length,\n        point = arc[0],\n        x0 = point[0],\n        y0 = point[1],\n        x1,\n        y1;\n\n    while (++j < m) {\n      point = arc[j], x1 = point[0], y1 = point[1];\n      if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n    }\n\n    if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.\n\n    arc.length = k;\n  }\n\n  return arcs;\n}\n", "// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nexport default function(objects) {\n  var index = -1,\n      lines = [],\n      rings = [],\n      coordinates = [];\n\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n\n  var extractGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },\n    LineString: function(o) { o.arcs = extractLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },\n    Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }\n  };\n\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n    var arc = {0: index - n + 1, 1: index};\n    lines.push(arc);\n    return arc;\n  }\n\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n    var arc = {0: index - n + 1, 1: index};\n    rings.push(arc);\n    return arc;\n  }\n\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n}\n", "// Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.\n// Any null input geometry objects are represented as {type: null} in the output.\n// Any feature.{id,properties,bbox} are transferred to the output geometry object.\n// Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!\nexport default function(inputs) {\n  var outputs = {}, key;\n  for (key in inputs) outputs[key] = geomifyObject(inputs[key]);\n  return outputs;\n}\n\nfunction geomifyObject(input) {\n  return input == null ? {type: null}\n      : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection\n      : input.type === \"Feature\" ? geomifyFeature\n      : geomifyGeometry)(input);\n}\n\nfunction geomifyFeatureCollection(input) {\n  var output = {type: \"GeometryCollection\", geometries: input.features.map(geomifyFeature)};\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nfunction geomifyFeature(input) {\n  var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  for (key in input.properties) { output.properties = input.properties; break; }\n  return output;\n}\n\nfunction geomifyGeometry(input) {\n  if (input == null) return {type: null};\n  var output = input.type === \"GeometryCollection\" ? {type: \"GeometryCollection\", geometries: input.geometries.map(geomifyGeometry)}\n      : input.type === \"Point\" || input.type === \"MultiPoint\" ? {type: input.type, coordinates: input.coordinates}\n      : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n", "export default function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },\n    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },\n    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },\n    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}\n", "import bounds from \"./bounds\";\nimport cut from \"./cut\";\nimport dedup from \"./dedup\";\nimport delta from \"./delta\";\nimport extract from \"./extract\";\nimport geometry from \"./geometry\";\nimport hashmap from \"./hash/hashmap\";\nimport prequantize from \"./prequantize\";\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nexport default function(objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n", "export default function(topology) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      oldArcs = topology.arcs,\n      oldArcsLength = oldArcs.length,\n      oldIndex = -1,\n      newIndexByOldIndex = new Array(oldArcsLength),\n      newArcsLength = 0,\n      newArcs,\n      newIndex = -1,\n      key;\n\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\": input.geometries.forEach(scanGeometry); break;\n      case \"LineString\": scanArcs(input.arcs); break;\n      case \"MultiLineString\": input.arcs.forEach(scanArcs); break;\n      case \"Polygon\": input.arcs.forEach(scanArcs); break;\n      case \"MultiPolygon\": input.arcs.forEach(scanMultiArcs); break;\n    }\n  }\n\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n\n  function reindexGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(reindexGeometry)}; break;\n      case \"LineString\": output = {type: \"LineString\", arcs: reindexArcs(input.arcs)}; break;\n      case \"MultiLineString\": output = {type: \"MultiLineString\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"Polygon\": output = {type: \"Polygon\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"MultiPolygon\": output = {type: \"MultiPolygon\", arcs: input.arcs.map(reindexMultiArcs)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n\n  newArcs = new Array(newArcsLength);\n\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n}\n", "import prune from \"./prune\";\n\nexport default function(topology, filter) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      key;\n\n  if (filter == null) filter = filterTrue;\n\n  function filterGeometry(input) {\n    var output, arcs;\n    switch (input.type) {\n      case \"Polygon\": {\n        arcs = filterRings(input.arcs);\n        output = arcs ? {type: \"Polygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"MultiPolygon\": {\n        arcs = input.arcs.map(filterRings).filter(filterIdentity);\n        output = arcs.length ? {type: \"MultiPolygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"GeometryCollection\": {\n        arcs = input.geometries.map(filterGeometry).filter(filterNotNull);\n        output = arcs.length ? {type: \"GeometryCollection\", geometries: arcs} : {type: null};\n        break;\n      }\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function filterRings(arcs) {\n    return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n        ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing))\n        : null;\n  }\n\n  function filterExteriorRing(ring) {\n    return filter(ring, false);\n  }\n\n  function filterInteriorRing(ring) {\n    return filter(ring, true);\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = filterGeometry(oldObjects[key]);\n  }\n\n  return prune({\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: topology.arcs\n  });\n}\n\nfunction filterTrue() {\n  return true;\n}\n\nfunction filterIdentity(x) {\n  return x;\n}\n\nfunction filterNotNull(geometry) {\n  return geometry.type != null;\n}\n", "export default function(topology) {\n  var ownerByArc = new Array(topology.arcs.length), // arc index -> index of unique associated ring, or -1 if used by multiple rings\n      ownerIndex = 0,\n      key;\n\n  function testGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(testGeometry); break;\n      case \"Polygon\": testArcs(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(testArcs); break;\n    }\n  }\n\n  function testArcs(arcs) {\n    for (var i = 0, n = arcs.length; i < n; ++i, ++ownerIndex) {\n      for (var ring = arcs[i], j = 0, m = ring.length; j < m; ++j) {\n        var arc = ring[j];\n        if (arc < 0) arc = ~arc;\n        var owner = ownerByArc[arc];\n        if (owner == null) ownerByArc[arc] = ownerIndex;\n        else if (owner !== ownerIndex) ownerByArc[arc] = -1;\n      }\n    }\n  }\n\n  for (key in topology.objects) {\n    testGeometry(topology.objects[key]);\n  }\n\n  return function(ring) {\n    for (var j = 0, m = ring.length, arc; j < m; ++j) {\n      if (ownerByArc[(arc = ring[j]) < 0 ? ~arc : arc] === -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n", "export function planarTriangleArea(triangle) {\n  var a = triangle[0], b = triangle[1], c = triangle[2];\n  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1])) / 2;\n}\n\nexport function planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area) / 2;\n}\n", "import {feature} from \"topojson-client\";\nimport {planarRingArea} from \"./planar\";\n\nexport default function(topology, minWeight, weight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  if (weight == null) weight = planarRingArea;\n\n  return function(ring, interior) {\n    return weight(feature(topology, {type: \"Polygon\", arcs: [ring]}).geometry.coordinates[0], interior) >= minWeight;\n  };\n}\n", "import filterAttached from \"./filterAttached\";\nimport filterWeight from \"./filterWeight\";\n\nexport default function(topology, minWeight, weight) {\n  var a = filterAttached(topology),\n      w = filterWeight(topology, minWeight, weight);\n  return function(ring, interior) {\n    return a(ring, interior) || w(ring, interior);\n  };\n}\n", "function compare(a, b) {\n  return a[1][2] - b[1][2];\n}\n\nexport default function() {\n  var heap = {},\n      array = [],\n      size = 0;\n\n  heap.push = function(object) {\n    up(array[object._ = size] = object, size++);\n    return size;\n  };\n\n  heap.pop = function() {\n    if (size <= 0) return;\n    var removed = array[0], object;\n    if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n    return removed;\n  };\n\n  heap.remove = function(removed) {\n    var i = removed._, object;\n    if (array[i] !== removed) return; // invalid request\n    if (i !== --size) object = array[size], (compare(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n    return i;\n  };\n\n  function up(object, i) {\n    while (i > 0) {\n      var j = ((i + 1) >> 1) - 1,\n          parent = array[j];\n      if (compare(object, parent) >= 0) break;\n      array[parent._ = i] = parent;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  function down(object, i) {\n    while (true) {\n      var r = (i + 1) << 1,\n          l = r - 1,\n          j = i,\n          child = array[j];\n      if (l < size && compare(array[l], child) < 0) child = array[j = l];\n      if (r < size && compare(array[r], child) < 0) child = array[j = r];\n      if (j === i) break;\n      array[child._ = i] = child;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  return heap;\n}\n", "import {transform} from \"topojson-client\";\nimport newHeap from \"./heap\";\nimport {planarTriangleArea} from \"./planar\";\n\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\n\nexport default function(topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n      heap = newHeap();\n\n  if (weight == null) weight = planarTriangleArea;\n\n  var arcs = topology.arcs.map(function(arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n\n    arc = arc.map(point);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latter’s weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;\n      else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    return arc;\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n", "export default function(topology, p) {\n  var array = [];\n\n  topology.arcs.forEach(function(arc) {\n    arc.forEach(function(point) {\n      if (isFinite(point[2])) { // Ignore endpoints, whose weight is Infinity.\n        array.push(point[2]);\n      }\n    });\n  });\n\n  return array.length && quantile(array.sort(descending), p);\n}\n\nfunction quantile(array, p) {\n  if (!(n = array.length)) return;\n  if ((p = +p) <= 0 || n < 2) return array[0];\n  if (p >= 1) return array[n - 1];\n  var n,\n      h = (n - 1) * p,\n      i = Math.floor(h),\n      a = array[i],\n      b = array[i + 1];\n  return a + (b - a) * (h - i);\n}\n\nfunction descending(a, b) {\n  return b - a;\n}\n", "export default function(topology, minWeight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  // Remove points whose weight is less than the minimum weight.\n  var arcs = topology.arcs.map(function(input) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        point;\n\n    while (++i < n) {\n      if ((point = input[i])[2] >= minWeight) {\n        output[j++] = [point[0], point[1]];\n      }\n    }\n\n    output.length = j;\n    return output;\n  });\n\n  return {\n    type: \"Topology\",\n    transform: topology.transform,\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n", "var pi = Math.PI,\n    tau = 2 * pi,\n    quarterPi = pi / 4,\n    radians = pi / 180,\n    abs = Math.abs,\n    atan2 = Math.atan2,\n    cos = Math.cos,\n    sin = Math.sin;\n\nfunction halfArea(ring, closed) {\n  var i = 0,\n      n = ring.length,\n      sum = 0,\n      point = ring[closed ? i++ : n - 1],\n      lambda0, lambda1 = point[0] * radians,\n      phi1 = (point[1] * radians) / 2 + quarterPi,\n      cosPhi0, cosPhi1 = cos(phi1),\n      sinPhi0, sinPhi1 = sin(phi1);\n\n  for (; i < n; ++i) {\n    point = ring[i];\n    lambda0 = lambda1, lambda1 = point[0] * radians;\n    phi1 = (point[1] * radians) / 2 + quarterPi;\n    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);\n\n    // Spherical excess E for a spherical triangle with vertices: south pole,\n    // previous point, current point.  Uses a formula derived from Cagnoli’s\n    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n    // See https://github.com/d3/d3-geo/blob/master/README.md#geoArea\n    var dLambda = lambda1 - lambda0,\n        sdLambda = dLambda >= 0 ? 1 : -1,\n        adLambda = sdLambda * dLambda,\n        k = sinPhi0 * sinPhi1,\n        u = cosPhi0 * cosPhi1 + k * cos(adLambda),\n        v = k * sdLambda * sin(adLambda);\n    sum += atan2(v, u);\n  }\n\n  return sum;\n}\n\nexport function sphericalRingArea(ring, interior) {\n  var sum = halfArea(ring, true);\n  if (interior) sum *= -1;\n  return (sum < 0 ? tau + sum : sum) * 2;\n}\n\nexport function sphericalTriangleArea(t) {\n  return abs(halfArea(t, false)) * 2;\n}\n"],
  "mappings": "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",
  "names": ["o", "arcs", "fragmentByEnd", "fragmentByStart", "object", "arcs", "polygon", "polygons", "i", "o", "n", "values", "i", "keys", "i", "i", "previousIndex", "currentIndex", "nextIndex", "indexes", "n", "j", "i", "n", "rings", "n", "pi", "oldIndex", "planarRingArea", "planarRingArea", "object"]
}
